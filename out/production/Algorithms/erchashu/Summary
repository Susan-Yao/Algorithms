二叉树
用<递归和非递归>的方式实现1-3
1.先序遍历 pre - 中左右
2.中序遍历 in  - 左中右
3.后序遍历 pos - 左右中
4.宽度优先遍历 - 用队列queue 先入先出
    e.g.求一颗二叉树的最大宽度 （需要知道每一层有几个数）
5.***二叉树的递归套路***
利用子树的信息 构建所有可能性
    5.1 判断以x根的树 是否为二叉搜索树 Binary Search Tree
    思路一：中序遍历是否递增
    思路二： 用 二叉树的递归套路
           条件1 - x的左子树是搜索二叉树
           条件2 - x的右子树是搜索二叉树
           条件3 - x的左子树上的最大值 < x; x的右子树上的最小值 > x

           需要左子树：是否是搜索二叉树 + max
           需要右子树：是否是搜索二叉树 + min

           整合：是否是搜索二叉树 + min + max - 为了递归

    5.2 判断以x根的树 是否为满二叉树 Full binary tree（max高度=h, 节点个数为N -> N = 2^h-1）
    思路一：求h，求N，看满不满足那个式子
    思路二：用 二叉树的递归套路
          信息：N，h

    5.3 判断以x根的树 是否为平衡二叉树 balanced binary tree（每棵子树的左子树和右子树的高度差 不超过1）

    5.4 最低公共祖先 - 低共 (以x为根的树，Node o1 与 Node o2 的最低公共祖先)
        信息：

    5.5 判断以x根的树 是否为完全二叉树 complete binary tree - 宽度优先遍历
        条件 1.遍历的任何一个节点，不能有右无左
            2.在不违反条件1的情况下，若遇到孩子不双全的节点，接下来遇到的节点，必须是叶子节点


