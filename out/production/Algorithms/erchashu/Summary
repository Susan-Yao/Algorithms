二叉树
用<递归和非递归>的方式实现1-3
1.先序遍历 pre - 中左右
2.中序遍历 in  - 左中右
3.后序遍历 pos - 左右中
4.宽度优先遍历 - 用队列queue 先入先出
    e.g.求一颗二叉树的最大宽度 （需要知道每一层有几个数）
5.***二叉树的递归套路***
利用子树的信息 构建所有可能性
    5.1 判断以x根的树 是否为二叉搜索树 Binary Search Tree
    思路一：中序遍历是否递增
    思路二  条件1 - x的左子树是搜索二叉树
           条件2 - x的右子树是搜索二叉树
           条件3 - x的左子树上的最大值 < x; x的右子树上的最小值 > x

           需要左子树：是否是搜索二叉树 + max
           需要右子树：是否是搜索二叉树 + min

           整合：是否是搜索二叉树 + min + max - 为了递归

