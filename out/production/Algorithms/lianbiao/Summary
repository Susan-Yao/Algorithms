哈希表：增删改查 O(1) - 与数据量无关，但常数时间比较大
对int/Integer - 按值传递
对自定义类型 - 按引用（地址）传递
hashMap (key-value) 方法：put, remove, get, containsKey
hashSet (只有key)    方法：put, remove, get, contains

有序表：增删改查 O(1) - 与数据量无关，但常数时间比较大
实现：红黑树（TreeMap），AVL树，跳表等
key-value 但key是有顺序的（可以用比较器来完成）
方法：firstKey, lastKey, floorKey（<=x中，离x最近的）, ceilingKey（>=x中，离x最近的）

链表（笔试不那么卡空间，面试非常卡空间）
1.反转单链表 reverse (single linked list)
    如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为 O(1)

2.反转双链表 reverse (double linked list)
    如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为 O(1)

3.打印两个<有序>链表的公共部分（不一定是连续的，只是找出所有value一样的点） common
    如果两个链表的长度之和为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)

4.判断一个链表是否为回文结构 Palindrome list
    笔试：遍历，放入栈stack（先入后出）；再遍历，与从栈中弹出的对比
    面试：***快慢指针*** （如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)）
        快指针一次走两步，慢指针一次走一步
        1.快指针走到结尾，慢指针走到中点
        2.将链表右半边反转
        3.一个从头开始移动，一个从尾开始移动，看是否一样
        4.将右半边反回来

5.将单向链表按某值划分成左边小、中间相等、右边大的形式 smallerEqualBigger
    笔试：快排的partition
        1.求链表的长度 l (遍历链表)
        2.新建一个数组，类型为Node，长度为l，把链表中的Node放入这个数组中
        3.对这个数组进行<快排的partition>,得到左边小、中间相等、右边大的数组
        4.将这个数组链接为链表
    面试：时间复杂度请达到O(N)，额外空间复杂度请达到O(1)
        1.准备6个变量 - sH，sT，eH，eT，mH，mT （小，等，大）
        2.遍历链表 看每个数属于哪个区域
        3.最后将sT，eH连起来，eT，mH连起来

6.复制含有随机指针节点的链表 copy with random
    笔试：用hashmap（自己定义的node，按地址传递）
        1.把新的node存到hashmap里
        2.再在hashmap里 定义每个node的next和random
    面试：不用hashmap - 时间复杂度O(N)，额外空间复杂度O(1)
        1.遍历老链表，
        把新的node放在老的node的下一个，
        把新node的random 放在原node的random的后面（next），以此替换hashmap
        eg. 1 - 1' - 2 - 2' - 3 - 3' - 4 - 4'......
        2.再把新的都拿出来

7.两个单链表相交的一系列问题 intersection - 如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)
包含了3个问题：
    7.1 判断一个单链表 有没有环 getLoopNode（有环：返回第一个入环节点；无环：返回空）
        （无环：一定是最后一个节点的next为null）
        笔试：用hashset遍历链表，若不在hashset 就加进去；若在 说明有环
        面试：快慢指针（以下流程 证明略） - 快指针F一次走两步，慢指针S一次走一步
            1.F与S都从头开始
            2.如果F遇到了null - 说明无环
            3.如果F没有遇到null - 说明有环，且F与S会在环上相遇
            4.F回到开头变成一次走一步，S不动，且仍为一次走一步
            5.继续走，当F与S再次相遇时，就是第一个入环节点

    7.2 两个无环单链表，怎么找到第一个相交的节点 noLoop（无环链表的相交问题）
    不想交：两条平行线
    相交：Y字形（不可能相交以后再叉开）
        笔试：用hashset，遍历H1，把H1放入set，再遍历H2 看在不在set。
             若发现在set，则这就是第一个相交的节点
        面试：
            1.遍历H1，找到尾e1，长度len1
            2.遍历H2，找到尾e2，长度len2
            3.若e1 = e2，说明相交，且它们是相交的最后一个节点；否则，不相交
            4.diff = |len1 - len2|，让长链表先走diff步
            5.然后两个链表一起走，对比两个节点是否一致，若一致，则为第一个相交的节点

    7.3 两个有环单链表，怎么找到第一个相交的节点
        bothLoop
